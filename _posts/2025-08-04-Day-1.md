---
layout: post
title: "[CLRS] 분할 정복"
date: 2025-08-04 11:00:00 +0900
categories:
  - algorithm
related_posts:
---

# 알고리즘의 기초 - 분할 정복

<!-- 부제목이 있다면 작성 -->

코딩 테스트 준비를 하다보니까 책을 보면서 공부하는게 내 성격에 맞는 것 같았다.
그래서 학교 커뮤니티에서 CLRS라는 책을 추천 받았는데 학부 때 교과서였음..

왜 그때 열심히 하지 않았을까 하는 생각이 자주 들지만, 그래도 지금 공부하는게 재밌게 느껴지니까 좋다.

CLRS의 맨 처음 부분은 점근적 복잡도의 엄밀한 정의부터 알고리즘의 기초가 되는 분할 정복 방법에 대한 소개가 나와있는데, 평소에 가려웠던 부분을 명쾌하게 짚어줘서 좋았다.

점근적 복잡도에 대한 부분은 나중에 따로 포스팅하고, 이번 글에서는 분할 정복에 대한 설명을 정리하려고 한다.
이제 1) 어떤 방법론을 분할 정복이라고 하는지, 2) 예시로 어떤 알고리즘이 있는지, 3) 어떻게 분석하는지 등을 얘기할거다.

## 1. 분할 정복이란

책에서는 앞서 병합 정렬을 간단하게 언급하면서 분할 정복 패러다임을 소개한 적이 있다.
(분할 정복은 재귀적으로 문제를 푼다, 재귀 트리의 각각의 레벨에서 3가지 단계로 동작)
분할해야 할 정도로 큰 subproblems -> recursive case
subproblems이 재귀호출할 필요 없을 정도로 작으면 recursion이 bottoms out했다고 말하고, 그런 문제들을 base case라고 함
///
이 챕터에서는 분할 정복 기반의 알고리즘 몇개를 살펴보고 이 패러다임이 갖는 의미
그리고 분할 정복 알고리즘 분석 방법을 알려줌(최대 부분수열, 스트라센)
알고리즘 몇개 ; 스트라센은 너무 깊이 볼 필요는 없고, 최대 부분수열은 실제로는 Kadane을 쓰지만
여기서는 분할 정복이 갖는 의미를 설명하기 위해 언급함
분할 정복 알고리즘 분석 방법; 치환법 / 재귀 트리 / 마스터 메서드(개쩜)
///
(알고리즘에 있어서 Design과 Analysis가 중요하다, 알고리즘의 점근적 복잡도가 어떻게 될지 분석할줄 알아야 상황에 맞는 알고리즘을 사용할 수 있다)

분할 정복에서는 base case까지 재귀가 일어나기 때문에 점화식을 세울 수 있다.
이 점화식이 분할 정복 알고리즘의 러닝 타임을 특징화함. 특징화한다는건 뭔 말이냐면
점화식을 통해서 러닝 타임이 얼마다 구할 수 있다는거. 점화식 = 그 분할 정복 알고리즘의 아이덴티티
점화식 더듬더듬 만지면서 이렇게 생긴 녀석이군, 해체하고 분석하면서 러닝 타임의 bound를 찾을 수 있음
더듬더듬 만지는게 3)의 치환법, 해체하고 분석하는게 마찬가지로 3)의 재귀 트리, 마스터 메서드임. 자세한건 그때가서 말하자

아무튼 점화식에는 분할과 결합에 대한 시간 복잡도가 포함되어있는데 이걸 왜 러프하게 다뤄도 괜찮은지에 대한 설명이 책에 나와있음(Technicalities in recurrences)
이건 대충 감으로 그러려니 하는것보다 점근적 복잡도에 대한 엄밀한 정의를 이해하는게 좋다. 그래야 어떤걸 무시하고 어떤걸 무시하면 안되는지 확실하게 판단할 수 있음. 그건 나중에 점근적 복잡도 포스팅에서 다루자.

## 2. 분할 정복 알고리즘 예시

### 1) 최대 부분 수열 문제

The Maximum-subarray problem in English
어떤 수열의 부분 수열들 중에, 원소의 합이 최대인 녀석을 최대 부분 수열이라고 한다.
그러면 그 녀석을 어떻게 찾을 수 있을까에 대한 문제가 최대 부분 수열 문제.

먼저 이 문제에 대한 설명이 나오는데, 먼저 일반 배열을 누적 합 배열로 바꾸는 스킬이 나오는데 이게 인상적
N개의 공간만을 더 사용함으로 동일한 정보를 다르게 표현했을 때, 문제 해결이 얼마나 편해지는가를 보여줌

아무튼 이 문제를 brute force하게 풀게 되면, N개의 요소 중에서 2개(subarray의 시작과 끝)를 고르는 경우의 수만큼 (<sub>n</sub>C<sub>2</sub>) 탐색하고, 또 그 안에서 최대값을 찾아야 하니까 아무리 잘해도 n<sup>2</sup>의 상수배인, 오메가 n<sup>2</sup>의 시간복잡도를 가진다.

이제 이걸 분할 정복으로 풀어보겠다. 현재 문제를 어떤 subproblems으로 나눌 수 있을까?
mid 지점을 찾은 후, 왼쪽 막대, 오른쪽 막대 각각에 속한 sub array 중에서 maximum subarray와
mid를 지나는(crossing) sub array 중에서 최대 부분수열을 비교
이러면 disjoint하면서, combine할 때 전체의 solution이 되는 subproblem으로 나눈것
그래서 수도 코드도 작성해보고 러닝 타임 분석해보면, 세타 n logn

병합 정렬과 동일한 결과(근데 Kadane을 쓰면 선형적인 시간으로 줄일 수 있음)

### 2) 스트라센 알고리즘

행렬 곱을 분할 정복으로 풀 때
재귀 호출을 8개 하는게 기본인데, 이걸 어떻게 온몸비틀기로 7개 호출로 줄였음
그 결과, log8=3에 대한 n<sup>3</sup>이 아니라 n<sup>log7</sup>의 시간 복잡도까지 줄일 수 있음

여기서 하고 싶은 말은 스트라센 알고리즘 외워라가 아니라
재귀 트리라는걸 소개하기 전에, 재귀 호출이 시간 복잡도에 끼치는 영향을 보여주고 싶은것

## 3. 분할 정복 알고리즘 분석 방법

### 1) 치환법

The substitution method
포켓몬에 대타 출동이라는 기술이 substitute다. 포켓몬에서는 자기 대신 공격을 맞아줄 대타를 소환하는건데
여기서는 분할 정복 알고리즘의 러닝 타임일 것 같은 값을 소환(추측)하는 것
너 대충 이 녀석 정도 시간 걸리지? 하고 때려맞추는거다(진짜임)
추측하고 나서, 수학적 귀납법으로 진짜 그 시간이 맞는지 확인하는게 치환법의 순서
다시 정리하면

1. 대충 추측
2. 진짜 맞는지 수학적 귀납법으로 증명
   이때 수학적 귀납법은 강한 수학적 귀납법이 사용되는데, 그냥 일반적인 수학적 귀납법과 동치인데
   자잘한 가정들을 하기 귀찮아서 사용하는거라고 이해하면 된다

그러면 어떻게 해야 추측을 잘할 수 있나요? 라는 질문에 불행하게도 정도는 없다고 함

### 2) 재귀 트리

하지만, 재귀 트리를 그릴 줄 알면, 좋은 추측을 할 수 있음. 사실 좋은 추측보다는 분석에 가까운데
level별 노드 수와 노드 당 비용을 알면, 레벨 별 비용을 알 수 있고, 그러면 자연스럽게 전체 러닝 타임을 알 수 있으니까

### 3) 마스터 정리

마스터 정리는 그냥 무적임. 우리 그 마스터 formula라고 불러야 하나, 일반적인 점화식 형태 기억할거임
거기서 a와 b값의 비율에 따라 f(n)(분할 및 결합 비용)을 구할 수 있음

하 이거는 나중에 마스터 정리 증명 부분 읽으면서 더 정확하게 정리하자. 일단은 이 정도
